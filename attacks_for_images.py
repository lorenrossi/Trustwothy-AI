# -*- coding: utf-8 -*-
"""Attacks for images.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1US1r1VwA0XBK2amIU-qHTPwNF71uIoj7
"""

!pip install torchattacks

!pip install adversarial-robustness-toolbox

!pip install deeprobust
!pip install scipy==1.7.3 --force-reinstall # Downgrade scipy for deeprobust compatibility
!pip install numba==0.57 llvmlite==0.40 --force-reinstall

!pip install timm

import torch
import time
import os
import torch.nn as nn
import torch.nn.functional as F
import torch.autograd as autograd
import torchvision
import torchvision.transforms as transforms
import numpy as np
import math
import pandas as pd
import random
import matplotlib.pyplot as plt
import timm

# Torch attacks
import torchattacks

# Adversarial Robustness Toolbox
from art.attacks.evasion import FastGradientMethod, ProjectedGradientDescent, CarliniLInfMethod
from art.estimators.classification import PyTorchClassifier

# Deeprobust
from deeprobust.image.attack.fgsm import FGSM
from deeprobust.image.attack.pgd import PGD
#from deeprobust.image.attack.cw import CW #Carlini-Wagner #Import fails
#from deeprobust.image.netmodels.CNN import Net  #Import fails

device = 'cuda' if torch.cuda.is_available() else 'cpu'

# -------------------------
# CHOOSE DATASET HERE!
dataset_name = "cifar10"   # <-- change to "cifar100"
# -------------------------

cifar_mean = [0.4914, 0.4822, 0.4465]
cifar_std  = [0.2023, 0.1994, 0.2010]

transform_test = transforms.Compose([
    transforms.ToTensor(),
    transforms.Normalize(cifar_mean, cifar_std),
])

if dataset_name == "cifar10":
  testset = torchvision.datasets.CIFAR10(
    root="./data", train=False, download=True, transform=transform_test)
  model = torch.hub.load("chenyaofo/pytorch-cifar-models", "cifar10_resnet20", pretrained=True)
  num_classes = 10

elif dataset_name == "cifar100":
  testset = torchvision.datasets.CIFAR100(
        root="./data", train=False, download=True, transform=transform_test
    )
  model = torch.hub.load("chenyaofo/pytorch-cifar-models", "cifar100_resnet20", pretrained=True)
  num_classes = 100

#model = timm.create_model(model_name, pretrained=True).to(device)
model.eval()

print("Loaded dataset:", dataset_name)
print("Total test images:", len(testset))

def evaluate(model, loader):
    correct = 0
    total = 0
    with torch.no_grad():
        for x, y in loader:
            x, y = x.to(device), y.to(device)
            logits = model(x)
            pred = logits.argmax(1)
            correct += (pred == y).sum().item()
            total += y.size(0)
    return correct / total

testloader = torch.utils.data.DataLoader(testset, batch_size=64, shuffle=False)

clean_acc = evaluate(model, testloader)
print("Clean accuracy:", clean_acc)

#L_0 attack

from scipy.optimize import differential_evolution

class OnePixelAttack:
    def __init__(self, model, num_pixels=1, max_iter=5, pop_size=400):
        self.model = model
        self.num_pixels = num_pixels
        self.max_iter = max_iter
        self.pop_size = pop_size

    def _predict(self, img_tensor):
        """Return predicted label for one image."""
        with torch.no_grad():
            logits = self.model(img_tensor)
            return logits.argmax(1).item()

    def _perturb(self, xs, img):
        xs = xs.astype(int)
        adv = img.clone()
        for x in xs:
            px, py, r, g, b = x
            adv[0, :, px, py] = torch.tensor([r/255, g/255, b/255], device=img.device)
        return adv

    def _attack_single(self, img, label):
        H, W = 32, 32

        # bounds: (x, y, r, g, b)
        bounds = []
        for _ in range(self.num_pixels):
            bounds += [(0, H-1), (0, W-1), (0, 255), (0, 255), (0, 255)]

        def fitness(xs):
            xs = xs.reshape(self.num_pixels, 5)
            adv = self._perturb(xs, img)
            pred = self._predict(adv)
            # minimize fitness → misclassification
            return 0 if pred != label else 1

        result = differential_evolution(
            fitness,
            bounds,
            maxiter=self.max_iter,
            popsize=self.pop_size,
            recombination=1,
            polish=False
        )

        best_xs = result.x.reshape(self.num_pixels, 5)
        adv = self._perturb(best_xs, img)
        return adv

    def __call__(self, images, labels):
        """Batch-compatible wrapper; processes each image independently."""
        adv_list = []
        for i in range(len(images)):
            adv = self._attack_single(images[i:i+1], labels[i].item())
            adv_list.append(adv)

        return torch.cat(adv_list, dim=0)

def test_attack(model, attack, x, y):
    model.eval()
    x_adv = attack(x, y)
    preds = model(x_adv).argmax(1)
    success = (preds != y).float().mean().item()
    return success, x_adv

images, labels = next(iter(testloader))
images, labels = images.to(device), labels.to(device)

epsilon = 6/255
num_pixels = 3

atk_fgsm = torchattacks.FGSM(model, eps=epsilon)
success, adv = test_attack(model, atk_fgsm, images, labels)
print("Torchattacks FGSM success:", success)

atk_pgd = torchattacks.PGD(model, eps=epsilon, alpha=2/255, steps=10)
success, adv = test_attack(model, atk_pgd, images, labels)
print("Torchattacks PGD success:", success)

#Very slow
onepix = OnePixelAttack(model, num_pixels=num_pixels)
success, adv = test_attack(model, onepix, images[:12], labels[:12])
print("One‑pixel attack success:", success)

